// Code: C:\var\lib\jenkins\workspace\ReleaseOps\SVMX_UIFW_SUM20\src\modules\com.servicemax.client.mvc\src\api.js
/**
 * # Package #
 * This package provides the Command, Operation, Responder tripod that allows an application to stand in various configurations
 * where an application can trigger a named event, have a Command class created to handle it, the Command determines the current
 * registered Operation to handle that command and may do additional processing, and when all is done, the Responder delivers
 * the resulting data back to the application.
 *
 * + *Command:* An event handler and dispatcher
 * + *Operation:* A Command typically dispatches the execution of an event to an Operation that is able to connect with the data source
 * + *Responder:* A class that may process the response to the operation and will call the event handler
 * + *CommandWithResponder:* Combines a Command and Responder 
 * 
 * @class com.servicemax.client.mvc.api
 * @singleton
 * @author Indresh 
 * 
 * @copyright 2013 ServiceMax, Inc. 
 */

(function(){
	
	var mvcApi = SVMX.Package("com.servicemax.client.mvc.api");
	
	/**
	 * A Command is an event handler class that listens for a named command that is triggered via an event
	 * by an Application.
     *
     *      // This sample shows a command that is just an event handler that detects when a GET_USERINFO
     *      // event has fired and dispatches handling of it to a registered operation class.
     *      sample.Class("GetUserInfo", com.servicemax.client.mvc.api.Command, {		
     *     	    executeAsync : function(request, responder){
     *     		    this._executeOperationAsync(request, responder, {operationId : "MYAPP.GET_USERINFO"});
     *     	    }
	 *      }, {});
	 *   
	 *      // This sample shows a command that has some logic of its own
     *      sample.Class("SaveData", com.servicemax.client.mvc.api.Command, {		
     *     	    executeAsync : function(request, responder){
     *     	        var data = request.data;
     *     	        if (this.validateData(data)) {
     *     		         this._executeOperationAsync(request, responder, {operationId : "MYAPP.SAVE_DATA"});
     *     		    }
     *     	    },
     * 	        validateData : function(data) {
     * 	           if (!data.Id) return false;
     * 	           if (data.budget != data.q1 + data.q2 + data.q3 + data.q4) return false;
     * 	           return true;
     * 	        }
	 *       }, {});
	 *
	 * You should never need to create a Command; commands are automatically generated when triggerEvent is called and
	 * your class name has been configured to respond to that triggerEvent.  Your module.json file should have:
	 *
	 *     {
	 *         "type" : "com.servicemax.client.runtime.namedinstance",
     *          "config" : {
     *     	        "configure" : { "name" : "CONTROLLER", "data" : [
	 *					{"event" : "MYAPP.GET_USERINFO", "command" : "com.servicemax.client.myclass.commands.GetUserInfo"},
	 *					{"event" : "MYAPP.SAVE_DATA", "command" : "com.servicemax.client.myclass.commands.SaveData"}
	 *				]
	 *			}
	 *     }
	 *
	 * @class com.servicemax.client.mvc.api.Command
	 * @extends com.servicemax.client.lib.api.AbstractCommand
	 * 
	 */
	mvcApi.Class("Command", com.servicemax.client.lib.api.AbstractCommand, {
		__controller : null, __eventBus : null,
		
		__constructor : function(){ this.__base(); },
		setController : function(value){ this.__controller = value; },
		setEventBus : function(value){ this.__eventBus = value; },
		executeAsync : function(request, responder) { },
		
		_executeOperationAsync : function(request, responder, options){
			this.__controller.getModel().executeOperationAsync(
				request, responder, options, this.getEventBus());
		},
		
		getController : function(){ return this.__controller; },
		getEventBus : function(){ return this.__eventBus; }
	}, {});
	
	

	/**
	 * An Operation is a class that knows how to execute some process and can be configured to have Commands dispatch those processes to it.
     *
     *      // This sample shows a command that is just an event handler that detects when a GET_USERINFO
     *  	// event has fired and dispatches handling of it to a registered operation class.
     *  	sample.Class("GetFile", com.servicemax.client.mvc.api.Operation, {		
	 *     	    performAsync : function(request, responder) { 
	 *     	      	var f = new nativeservice.File(request.filePath + request.recordId);
 	 *    	      	f.read().then(function(inSuccess, inData) {
	 *     	      	    responder.result(isSuccess ? inData : null);
	 *     	      	});
	 *       	}
	 *      }, {});
	 *
	 * The `responder.result()` should ALWAYS be called, even in the event of an error.  
	 *
	 * See the Responder class for more information.
	 *
	 * You should never need to create a Operation; operations are automatically generated by com.servicemax.client.mvc.impl.Model
	 * when the Command class tries to dispatch processing to any registered operation.  Your module.json file should have:
	 *
	 *     "defines" : [
     *	    	{
     *		    	"type" : "com.servicemax.client.runtime.namedinstance",
     *			    "config" : {
     * 				    "configure" : { "name" : "MODEL", "data" : [
     *					    {"operationId" : "MYAPP.GET_FILE", "operation" : "com.servicemax.client.myapp.operations.GetFile"},
     *					    ...
     *			     	]
     *			    }
     *		    }
     *     ]
	 * @class com.servicemax.client.mvc.api.Operation
	 * @extends com.servicemax.client.lib.api.AbstractOperation
	 * 
	 */	
	mvcApi.Class("Operation", com.servicemax.client.lib.api.AbstractOperation, {
		__eventBus : null,
		__constructor : function(){ this.__base(); },
		performAsync : function(request, responder) { },
		
		setEventBus : function(value){ this.__eventBus = value; },
		getEventBus : function(){ return this.__eventBus; }
	}, {});
	
	mvcApi.Class("Responder", com.servicemax.client.lib.api.AbstractResponder, {
		__constructor : function() { this.__base(); },
		result : function(data) { },
		fault : function(data) { }
	}, {});
	
	mvcApi.Class("CommandWithResponder", mvcApi.Command, {
		__responder : null, // Optional field, in case the invoker wants to customize the callback
		__constructor : function() { this.__base(); },
        executeAsync : function(request, responder) { 
            this.__base();
            this.__responder = responder;
        },
		
		// responder
		result : function(data) { 
		    if (this.__responder) this.__responder(data);
		},
		
		fault : function(data) { }
		// end responder
		
	}, {});
})();

// end of file

// Code: C:\var\lib\jenkins\workspace\ReleaseOps\SVMX_UIFW_SUM20\src\modules\com.servicemax.client.mvc\src\impl.js
/**
 * # Package #
 * This package provides the Controller and Model classes, which are used as part of our MVC framework.
 *
 * @class com.servicemax.client.mvc.impl
 * @singleton
 * @author Indresh
 *
 * @copyright 2013 ServiceMax, Inc.
 */



(function(){

    var mvcImpl = SVMX.Package("com.servicemax.client.mvc.impl");

    mvcImpl.Class("Module", com.servicemax.client.lib.api.ModuleActivator, {
        __constructor : function(){
            this.__base();
        },

        beforeInitialize : function(){
            mvcImpl.init();
        },

        initialize : function(){

        },

        afterInitialize : function(){

        }
    }, {});

mvcImpl.init = function(){

    /**
     * The Controller class is a NamedInstance which provides controller-like behaviors to a class that uses it.
     * The role of the Controller is to wire events between a module's controller (currently engine.js but perhaps will be renamed to controller.js)
     * and the module's commands.js file where commands are executed.
     *
     * It does this by taking the list of all events that have been registered via manifest.json, taking the eventBus of the Module's controller/engine
     * and subscribing/binding to all of these registered events that come through this eventBus.
     *
     * Events are configured in module.json as:
     *
     *     {
     *           "type" : "com.servicemax.client.runtime.namedinstance",
     *           "config" : {
     *               "configure" : { "name" : "CONTROLLER", "data" : [
     *                   {"event" : "SFMDELIVERY.GET_PAGELAYOUT", "command" : "com.servicemax.client.sfmdelivery.commands.GetPageLayout"}
     *               ]
     *           }
     *     }
     *
     * On triggering an event, the class specified by the "command" in the config above is created, and its executeAsync() method is called
     *
     * @class com.servicemax.client.mvc.impl.Controller
     * @extends com.servicemax.client.runtime.api.AbstractNamedInstance
     */
    mvcImpl.Class("Controller", com.servicemax.client.runtime.api.AbstractNamedInstance, {
        __eventId2EventMap : null, _model : null, __logger : null, __eventBus : null,

        __constructor : function(){

        },

        /**
         * @method
         * @protected
         * Initialize the Controller
         *
         * The initialize method is part of the namedInstance lifecycle, and should only ever be called by NamedInstanceService.
         * Its main activity is to bind all configured events to trigger this object's eventHandler method.
         */
        initialize : function(name, data, params){
            this.__logger = SVMX.getLoggingService().getLogger("MVC-CONTROLLER(" + name +")");
            this.__eventId2EventMap = {};
            var eventBus = params.eventBus; this.__eventBus = params.eventBus;
            var i, count = data.length;
            for(i = 0; i < count; i++){
                var d = data[i];
                var eventMap = d.data, eventCount = eventMap.length, j;
                for(j = 0; j < eventCount; j++){
                    var mapping = eventMap[j];
                    this.__eventId2EventMap[mapping.event] = { data : d, mapping : mapping };
                    eventBus.bind(mapping.event, this.eventHandler, this);
                }
            }
        },

        /**
         * @method
         * @protected
         * Executes the configured event.
         *
         * The eventHandler method was passed in via initialize's bind method, and should only be called via a triggerEvent() call.
         * This method instantiates and executes the configured Command class when an event is triggered.
         */
        eventHandler : function(evt){
            try{
                var eventInfo = this.__eventId2EventMap[evt.type];
                var commandClassName = eventInfo.mapping.command;

                //TODO : Load the module if it is already not loaded

                var commandClass = SVMX.getClass(commandClassName);
                var cmd = new commandClass();
                cmd.setController(this);
                cmd.setEventBus(this.__eventBus);

                var request = evt.data.request;
                var responder = evt.data.responder;
                this.__logger.info("Executing command => " + evt.type);
                cmd.executeAsync(request, responder);
            }catch(e){
                this.__logger.error(e);
                throw e;
            }
        },

        /**
         * @method
         * Set the model that will be used in executing events
         *
         * The commands that are executed are typically executed using sal.model or offline.sal.model, or some other configured model.
         * The knowledge of who provides the operations needed by many commands is managed by the mvc.Model class.
         * This method is called by the module's engine.js/controller.js file.
         *
         * @param {com.servicemax.client.mvc.impl.Model} model
         */
        setModel : function(value){
            this._model = value;
        },

        /**
         * @method
         * Retrieve the model
         *
         * @param {com.servicemax.client.mvc.impl.Model} model
         */
        getModel : function(){ return this._model; }

    }, {});



    /**
     * The Model class is a NamedInstance which provides controller-like behaviors to a class that uses it.
     * The role of the Model is to wire events between a module's commands (i.e. commands.js)
     * and the the Operation class/module that implements that operation.
     * This allows us to configure what gets executed when a command needs to interact with the server/database (via module.json file)
     * and allows us to configure whether its using the database OR the server (by including the module whose module.json file that defines the operations)
     *
     * It does this by taking the list of all events that have been registered via manifest.json, taking the eventBus of the Module's controller/engine
     * and subscribing/binding to all of these registered events that come through this eventBus.
     *
     * Events are configured in module.json as:
     *
     *
        {
            "type" : "com.servicemax.client.runtime.namedinstance",
            "config" : {
                "configure" : { "name" : "MODEL", "data" : [
                        {"operationId" : "SFMDELIVERY.GET_PAGELAYOUT", "operation" : "com.servicemax.client.offline.sal.model.sfmdelivery.operations.GetPageLayout"}
                ]}
            }
        }
     *
     * When a Command wants to execute an operation, it then executes:
     *
     *     this.__controller.getModel().executeOperationAsync(request, responder, options, this.getEventBus());
     *
     * Which then routes the requested operation to the appropriate Operation instance according to the config shown above.
     *
     * @class com.servicemax.client.mvc.impl.Model
     * @extends com.servicemax.client.runtime.api.AbstractNamedInstance
     */
    mvcImpl.Class("Model", com.servicemax.client.runtime.api.AbstractNamedInstance, {

        __operationId2OperationMap : null, __logger : null,

        __constructor : function(){},

        /**
         * @method
         * @protected
         * Initialize the Model
         *
         * The initialize method is part of the namedInstance lifecycle, and should only ever be called by NamedInstanceService.
         * Its main activity is to bind all configured events to trigger this object's eventHandler method.
         */
        initialize : function(name, data, params){
            this.__logger = SVMX.getLoggingService().getLogger("MVC-MODEL(" + name +")");
            this.__operationId2OperationMap = {};
            var i, count = data.length;
            for(i = 0; i < count; i++){
                var d = data[i];
                var opMap = d.data, opCount = opMap.length, j;
                for(j = 0; j < opCount; j++){
                    var mapping = opMap[j];
                    this.__operationId2OperationMap[mapping.operationId] = { data : d, mapping : mapping };
                }
            }
        },

        /**
         * @method
         * Execute the requested Operation.
         *
         * @param request
         * @param responder
         * @param options = { operationId : "" }
         */
        executeOperationAsync : function(request, responder, options, eventBus){
            try{
                var operationInfo = this.__operationId2OperationMap[options.operationId];

                // Operation is not supported for the current application.  See LookupItemSelected operation for offline sal model vs online model for example.
                if (!operationInfo) return;

                var operationClassName = operationInfo.mapping.operation;

                //TODO : Load the module if it is already not loaded

                var operationClass = SVMX.getClass(operationClassName);
                var op = new operationClass();
                op.setEventBus(eventBus);
                op.performAsync(request, responder);
            }catch(e){
                this.__logger.error(e);
                throw e;
            }
        }

    }, {});

mvcImpl.Class("View", com.servicemax.client.runtime.api.AbstractNamedInstance, {
        __viewConfig: null,
        __logger: null,
        __eventBus: null,

        __constructor : function(){},

        /**
         * @method
         * @protected
         * Initialize the View
         * @param {String} name Should always be "VIEW"
         * @param {Object} data All the data configured in all of the module.json files
         * @param {Object} params All the data passed from the createNamedInstanceAsync call
         *
         * The initialize method is part of the namedInstance lifecycle, and should only ever be called by NamedInstanceService.
         * Its main activity is to bind all configured events to trigger this object's eventHandler method.
         */
        initialize : function(name, data, params){
            this.__logger = SVMX.getLoggingService().getLogger("MVC-VIEW(" + name +")");
            this.__viewConfig = {};
            if (!params) params = {};
            this.__eventBus = params.eventBus;
            SVMX.array.forEach(data, function(dataSet) {
                SVMX.array.forEach(dataSet.data, function(item) {
                    var componentId = item["component-id"];
                    this.__viewConfig[componentId] = item["class-name"];
                }, this);
            }, this);
        },

        /**
         * @method
         * Create an instance of the specified component
         *
         * @param {String} componentId An id of a component "ROOTCONTAINER". Ids defined in module.json, and provided by each implementation of the UI
         * @param {Object} params Any parameters to pass into the constructor.
         */
        createComponent : function(componentId, params){
            try{
                var className = this.__viewConfig[componentId];
                if (!params) params = {};
                params.__view = this;

                // As of stateManager/android refactoring, this is no longer Required to return an object
                if (className && SVMX.getClass(className,true)) {
                    return SVMX.create(className, params);
                }
            }catch(e){
                this.__logger.error("Error creating " + componentId + ": " + e);
                throw e;
            }
        },

        /* Should share the deliveryEngine's event bus so that the view module can easily trigger events on it */
        triggerEvent : function(e) {
            this.__eventBus.triggerEvent(e);
        }

    }, {});
};
})();

// end of file

